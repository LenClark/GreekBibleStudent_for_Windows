using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.IO;

namespace GreekBibleStudent
{
    internal class classSearch
    {
        /*==================================================================================================================*
         *                                                                                                                  *
         *                                                classSearch                                                       *
         *                                                ===========                                                       *
         *                                                                                                                  *
         *  All methods relating to performing and managing the search function.                                            *
         *                                                                                                                  *
         *  Since the processing is quite convoluted, this summary constitutes a road-map of methods.                       *
         *                                                                                                                  *
         *  Following the more obvious, global variables, we define:                                                        *
         *    a) searchThread: what will be a background thread performing the actual search;                               *
         *    b) definition of a number of delegates                                                                        *
         *    c) the procedures that implement the delegates.                                                               *
         *  These are:                                                                                                      *
         *                                                                                                                  *
         *     Delegate                    Related Procedure                                                                *
         *     --------                    -----------------                                                                *
         *                                                                                                                  *
         *   performGroupboxAddition       addGroupbox                                                                      *
         *   performCheckboxAddition       addCheckbox                                                                      *
         *   performToolStripMessage       displayToolStripMessage     Display messages in the tool bar of the search area  *
         *   controlMTBaseSearch                                                                                            *
         *   controlLXXBaseSearch                                                                                           *
         *                                                                                                                  *
         *  These are followed by:                                                                                          *
         *                                                                                                                  *
         *   classSearch                   The initialising method for the class.                                           *
         *                                 Slave methods:                                                                   *
         *                                   searchOptionCheckedChanged         Called when a checkbox value is changed     *
         *                                                                                                                  *
         *  Other "setup" procedures are generated by buttons in the lower right Search tabs.  These are:                   *
         *                                                                                                                  *
         *     Form Button                           Procedure                                                              *
         *     -----------                           ---------                                                              *
         *                                                                                                                  *
         *   Main menu - Set Search Details       searchSetup                                                               *
         *                                          slave method:  hideOrShowAdvancedSearch                                 *
         *   Advanced Search button               setSearchType                                                             *
         *                                                                                                                  *
         *  The main form class will call the following method when either of the "Perform Search" buttons are clicked:     *
         *                                                                                                                  *
         *   controlSearch                                                                                                  *
         *                                                                                                                  *
         *  This, in turn, will call the following background task:                                                         *
         *                                                                                                                  *
         *   threadControl                                                                                                  *
         *                                                                                                                  *
         *  From this point on the background sequence will be as follows:                                                  *
         *                                                                                                                  *
         *         Masoretic Text (currentVersion = 0)                       Septuagint (currentVersion = 1)                *
         *         -----------------------------------                       -------------------------------                *
         *                                                                                                                  *
         *       mtBaseSearch  ->                                         lxxBaseSearch ->                                  *
         *          initialMTMatchProcessing                              initialLXXMatchProcessing                         *
         *          primaryMTScan                                         primaryLXXScan                                    *
         *          secondaryMTScan                                       secondaryLXXScan                                  *
         *          isThereAnMTMatch -> removeNonConsonents               isThereAnLXXMatch                                 *
         *          mtVerifyWord -> getStrongRefs                         lxxVerifyWord                                     *
         *          displayMTResults                                      displayLXXResults                                 *
         *                                                                                                                  *
         *                                                                                                                  *
         *                                                                                                                  *
         *  The following methods are used in the display processing by both MT and LXX:                                    *
         *                                                                                                                  *
         *    initialSetupOfRText      initial setup of a created RichTextBox                                               *
         *    getNewRTXHeight          Get the height of the text written to a RichTextBox                                  *
         *    resetRTX                 Reset the height of both RichTextBoxes in a given row                                *
         *                                                                                                                  *
         *==================================================================================================================*/

        /*------------------------------------------------------------------------------------------------------*
         *                                                                                                      *
         *  Constants:                                                                                          *
         *  ---------                                                                                           *
         *                                                                                                      *
         *  zeroWidthSpace      Used to mark the start of a word (making identification of words easier)        *
         *  zeroWidthNonJoiner  Separates the base word from prefixed "words" (normally extraneous symbols)     *
         *  noBreakSpace        Used in references to avoid breaking across references and other odd changes    *
         *  ideographicSpace    Used in book names that contain spaces (so we can keep book names intact)       *
         *                                                                                                      *
         *------------------------------------------------------------------------------------------------------*/

        const String zeroWidthSpace = "\u200b", zeroWidthNonJoiner = "\u200d", noBreakSpace = "\u00a0", ideographicSpace = "\u3000";
        //        const int col1Width = 200, flowSpacer = 30;

        bool isSearchSuccessful = false, isWordGiven, isSWordGiven;
        int noOfMatchingVerses, currentVersion, currentSearchType, matchType = 0,
            noOfRTXLines, noOfAllMatches = 0, displayAlignment;

        SortedList<int, classPrimaryResult> listOfPrimaryResults = new SortedList<int, classPrimaryResult>();
        SortedList<int, classSearchMatches> allMatches = new SortedList<int, classSearchMatches>();
        SortedSet<int> strongRefs;
        SortedSet<int> SecondStrongRefs;
        RichTextBox resultsTextView;
        ToolStripStatusLabel toolStriplabel;
        frmMain mainForm;
        frmProgress progressForm;
        classGlobal globalVars;
        classNTText ntText;
        classLXXText lxxText;
        classLexicon lexicon;
        classGreek greekProcs;
        classNote noteProcs;

        Thread searchThread;

        private delegate void performProgressAdvance(String primaryMessage, String secondaryMessage, bool useSecondary);
        private delegate void performToolStripMessage(StatusStrip searchStrip, int toolStripIndex, String message);
        private delegate void performMainFormLabelChange(Label labLabelLbl, String newText);
        private delegate void performListBoxEntry(ListBox lbTarget, String newEntry);
        private delegate void performListBoxSelection(ListBox lbTarget);
        private delegate void performRichTextBoxUpdate(RichTextBox rtxtTarget, int actionCode, Object actionData);
        private delegate void performProcessStopButton(bool willBeVisible);

        /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                                  *
         *                               Variables that are required across methods                                         *
         *                               ==========================================                                         *
         *                                                                                                                  *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

        int noOfBooksIncluded;
        SortedList<int, classBook> booksToInclude = new SortedList<int, classBook>();

        private void updateProgress(String mainMessage, String secondaryMessage, bool useSecondary)
        {
            progressForm.incrementProgress(mainMessage, secondaryMessage, useSecondary);
        }

        private void changeLabel(Label labLabelLbl, String newText)
        {
            labLabelLbl.Text = newText;
        }

        private void addListboxItem(ListBox lbTarget, String newEntry)
        {
            lbTarget.Items.Add(newEntry);
        }

        private void selectListboxItem(ListBox lbTarget)
        {
            if (lbTarget.Items.Count > 0) lbTarget.SelectedIndex = 0;
        }

        private void processStopButton( bool willBeVisible)
        {
            Button stopButton;

            stopButton = globalVars.BtnStop;
            stopButton.Visible = willBeVisible;
        }

        private void updateRichTextBox(RichTextBox rtxtTarget, int actionCode, Object actionData)
        {
            /*========================================================================================================*
             *                                                                                                        *
             *                                      updateRichTextBox                                                 *
             *                                      =================                                                 *
             *                                                                                                        *
             *  Controlled use of RichTextBox.  Action codes are:                                                     *
             *                                                                                                        *  
             *   0    Set the background colour                                                                       *
             *   1    Simple text allocation (erases all previous text)                                               *
             *   2    Specification of Font for following text                                                        *
             *   3    Specification of Colour for following text                                                      *
             *   4    Appending text to existing text                                                                 *
             *                                                                                                        *
             *========================================================================================================*/

            switch ( actionCode)
            {
                case 0: rtxtTarget.BackColor = (Color)actionData; break;
                case 1: rtxtTarget.Text = actionData.ToString(); break;
                case 2: rtxtTarget.SelectionFont = (Font) actionData; break;
                case 3: rtxtTarget.SelectionColor = (Color) actionData; break;
                case 4: rtxtTarget.SelectedText = actionData.ToString(); break;
                case 5: rtxtTarget.SelectionCharOffset = 10 * ((int) actionCode); break;
            }
        }

        private void displayToolStripMessage(StatusStrip searchStrip, int toolStripIndex, String message)
        {
            searchStrip.Items[toolStripIndex].Text = message;
        }

        public classSearch(frmMain callingForm, classGlobal inGlobal, classLexicon inLex, classGreek inGkProcs,
            classNTText inNTText, classLXXText inLXXText, classNote inNote, frmProgress inProg)
        {
            int idx;
            classBook currentBook;
            ListBox lbAvailableBooks;

            progressForm = inProg;
            progressForm.Invoke(new performProgressAdvance(updateProgress), "Initialising Search Facility", "", false);
            mainForm = callingForm;
            globalVars = inGlobal;
            lexicon = inLex;
            greekProcs = inGkProcs;
            ntText = inNTText;
            lxxText = inLXXText;
            noteProcs = inNote;

            // Configure booklist
            lbAvailableBooks = globalVars.LbAvailableBooks;
            for (idx = 0; idx < globalVars.NoOfAllBooks; idx++)
            {
                globalVars.BookList.TryGetValue(idx, out currentBook);
                if (currentBook != null)
                {
                    lbAvailableBooks.Invoke(new performListBoxEntry(addListboxItem), lbAvailableBooks, currentBook.BookName);
                }
            }
            lbAvailableBooks.Invoke(new performListBoxSelection(selectListboxItem), lbAvailableBooks);
            globalVars.getLabel(2).Invoke(new performMainFormLabelChange(changeLabel), globalVars.getLabel(2), "Search Initialisation Complete");
        }

        public void populateAvailableBoolsListbox()
        {
            bool isUse;
            int idx, seqCount = 0;
            classBook currentBook;
            ListBox lbAvailableBooks;
            SortedList<int, String> listOfCurrentBooks = new SortedList<int, string>();

            lbAvailableBooks = globalVars.LbAvailableBooks;
            isUse = globalVars.getRadioButton(2).Checked;
            for (idx = 0; idx < globalVars.NoOfAllBooks; idx++)
            {
                globalVars.BookList.TryGetValue(idx, out currentBook);
                if (isUse)
                {
                    if (globalVars.getCheckBox(currentBook.Category - 1).Checked)
                        listOfCurrentBooks.Add(seqCount++, currentBook.BookName);
                }
                else
                {
                    if (!globalVars.getCheckBox(currentBook.Category - 1).Checked)
                        listOfCurrentBooks.Add(seqCount++, currentBook.BookName);
                }
            }
            lbAvailableBooks.Items.Clear();
            lbAvailableBooks.Items.AddRange(listOfCurrentBooks.Values.ToArray());
        }

        public void searchSetup(int tagVal, int controlTab)
        {
            int bookId, chapSeq, verbSeq;
            classBook currentBook;
            classChapter currentChapter;
            classVerse currentVerse;

            switch (controlTab)
            {
                case 0:
                    bookId = globalVars.getComboBoxItem(0).SelectedIndex + globalVars.NoOfLXXBooks;
                    chapSeq = globalVars.getComboBoxItem(1).SelectedIndex;
                    verbSeq = globalVars.getComboBoxItem(2).SelectedIndex;
                    globalVars.BookList.TryGetValue(bookId, out currentBook);
                    currentChapter = currentBook.getChapterBySequence(chapSeq);
                    switch (tagVal)
                    {
                        case 1:
                            // Add the last selected word to the primary text box
                            globalVars.getTextbox(0).Text = greekProcs.reduceToBareGreek(globalVars.LastSelectedNTWord, false);
                            globalVars.PrimaryBookId = bookId;
                            globalVars.PrimaryChapNo = currentBook.getChapterRefBySequence(chapSeq);
                            globalVars.PrimaryVNo = currentChapter.getVerseRefBySeqNo(verbSeq);
                            globalVars.PrimaryWordSeq = globalVars.SelectedNTWordSequence;
                            globalVars.PrimaryWord = globalVars.LastSelectedNTWord;
                            break;
                        case 2:
                            globalVars.getTextbox(1).Text = greekProcs.reduceToBareGreek(globalVars.LastSelectedNTWord, false);
                            globalVars.SecondaryBookId = bookId;
                            globalVars.SecondaryChapNo = currentBook.getChapterRefBySequence(chapSeq);
                            globalVars.SecondaryVNo = currentChapter.getVerseRefBySeqNo(verbSeq);
                            globalVars.SecondaryWordSeq = globalVars.SelectedNTWordSequence;
                            globalVars.SecondaryWord = globalVars.LastSelectedNTWord;
                            hideOrShowAdvancedSearch(true);
                            break;
                    }
                    break;
                case 1:
                    bookId = globalVars.getComboBoxItem(3).SelectedIndex;
                    chapSeq = globalVars.getComboBoxItem(4).SelectedIndex;
                    verbSeq = globalVars.getComboBoxItem(5).SelectedIndex;
                    globalVars.BookList.TryGetValue(bookId, out currentBook);
                    currentChapter = currentBook.getChapterBySequence(chapSeq);
                    switch (tagVal)
                    {
                        case 1:
                            // Add the last selected word to the primary text box
                            globalVars.getTextbox(0).Text = greekProcs.reduceToBareGreek(globalVars.LastSelectedLXXWord, false);
                            globalVars.PrimaryBookId = bookId;
                            globalVars.PrimaryChapNo = currentBook.getChapterRefBySequence(chapSeq);
                            globalVars.PrimaryVNo = currentChapter.getVerseRefBySeqNo(verbSeq);
                            globalVars.PrimaryWordSeq = globalVars.SelectedLXXWordSequence;
                            globalVars.PrimaryWord = globalVars.LastSelectedLXXWord;
                            break;
                        case 2:
                            globalVars.getTextbox(1).Text = greekProcs.reduceToBareGreek(globalVars.LastSelectedLXXWord, false);
                            globalVars.SecondaryBookId = bookId;
                            globalVars.SecondaryChapNo = currentBook.getChapterRefBySequence(chapSeq);
                            globalVars.SecondaryVNo = currentChapter.getVerseRefBySeqNo(verbSeq);
                            globalVars.SecondaryWordSeq = globalVars.SelectedLXXWordSequence;
                            globalVars.SecondaryWord = globalVars.LastSelectedLXXWord;
                            hideOrShowAdvancedSearch(true);
                            break;
                    }
                    break;
            }
            globalVars.getTabControl(1).SelectedIndex = 2;
            globalVars.getTabControl(2).SelectedIndex = 2;
        }

        private void hideOrShowAdvancedSearch(bool isToShow)
        {
            globalVars.getLabel(0).Visible = isToShow;
            globalVars.UdWordDistance.Visible = isToShow;
            globalVars.getLabel(1).Visible = isToShow;
            globalVars.getTextbox(1).Visible = isToShow;
            if (isToShow) globalVars.BtnSearchType.Text = "Basic Search";
            else globalVars.BtnSearchType.Text = "Advanced Search";
        }

        public void initiateSearch()
        {
            searchThread = new Thread(new ThreadStart(controlSearch));
            searchThread.IsBackground = true;
            searchThread.Start();
        }

        private void controlSearch()
        {
            /*======================================================================================================*
             *                                                                                                      *
             *                                           controlSearch                                              *
             *                                           =============                                              *
             *                                                                                                      *
             *  Key variables used in the procedure:                                                                *
             *  -----------------------------------                                                                 *
             *                                                                                                      *
             *  searchType          Indicates whether the search is "simple" (a single word) or "complex" (one word *
             *                      withing n words of a second). The identification is based on whether lblWithin  *
             *                      is visible or not.                                                              *
             *                      Values of searchType are:                                                       *
             *                        simple:   1                                                                   *
             *                        complex:  2                                                                   *
             *  matchType           The type of matching strategy, as determined by the radio button selected.      *
             *                      Values and significances are:                                                   *
             *                        1    matching is based on the root of the word.                               *
             *                        2    matching is "exact" - i.e. identical in form (except for accents)        *
             *                                                                                                      *
             *  Processing:                                                                                         *
             *  ==========                                                                                          *
             *                                                                                                      *
             *  The ultimate purpose of this method (together with its subsidiary methods) is to populate a series  *
             *    of classSearchResults instances, all of which are stored (temporariy) in the global list,         *
             *    currentSearchResults.  These can then be interrogated by the separate method that actually        *
             *    displays them.                                                                                    *
             *                                                                                                      *
             *======================================================================================================*/

            bool stateCheck;
            int idx, noOfAllBooks, noOfSearchedBooks = 0;
            String searchWord, secondarySearchWord;
            String[] listboxData;
            Label labSample;
            TextBox txtKeyWord;
            RadioButton rbtnMatchType, rbtnInclude;
            ListBox.ObjectCollection listboxCollection;
            classBook currentBook;

            matchType = 0;
            isWordGiven = false;
            isSWordGiven = false;

            /*----------------------------------------------------------------------------------------------*
             * Provide initial progress information in the tool strip below the search results area.        *
             *----------------------------------------------------------------------------------------------*/
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Performing your search");

            booksToInclude.Clear();

            /*----------------------------------------------------------------------------------------------*
             * Check whether the search is "simple" or "complex"                                            *
             *   Set searchType accordingly, then invoke lexicon.performSearch as suitable                  *
             *----------------------------------------------------------------------------------------------*/
            txtKeyWord = globalVars.getTextbox(0);
            if (txtKeyWord.Text.Length == 0)
            {
                MessageBox.Show("You have selected a Search with no Primary word", "Search Error",
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            labSample = globalVars.getLabel(1);
            if (!labSample.Visible) currentSearchType = 1;
            else
            {
                txtKeyWord = globalVars.getTextbox(1);
                if (txtKeyWord.Text.Length == 0)
                {
                    MessageBox.Show("You have selected a Search with no Secondary word", "Search Error",
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                currentSearchType = 2;
            }

            /*----------------------------------------------------------------------------------------------*
             * Record the search type: based on root or exact match criteria.                               *
             *----------------------------------------------------------------------------------------------*/
            rbtnMatchType = globalVars.getRadioButton(0);
            if (rbtnMatchType.Checked) matchType = 1;
            else
            {
                rbtnMatchType = globalVars.getRadioButton(1);
                if (rbtnMatchType.Checked) matchType = 2;
            }
            rbtnInclude = globalVars.getRadioButton(2);
            noOfAllBooks = globalVars.NoOfAllBooks;
            listboxCollection = globalVars.LbAvailableBooks.Items;
            listboxData = new string[listboxCollection.Count];
            for (idx = 0; idx < listboxCollection.Count; idx++)
            {
                listboxData[idx] = listboxCollection[idx].ToString();
            }
            for (idx = 0; idx < noOfAllBooks; idx++)
            {
                // Is the current book in the list to be searched?
                currentBook = null;
                globalVars.BookList.TryGetValue(idx, out currentBook);
 //               if (rbtnInclude.Checked)
                {
                    if (listboxData.Contains(currentBook.BookName)) booksToInclude.Add(noOfSearchedBooks++, currentBook);
                }
 /*               else
                {
                    if (!listboxData.Contains(currentBook.BookName)) booksToInclude.Add(noOfSearchedBooks++, currentBook);
                } */
            }
            globalVars.BtnStop.Invoke(new performProcessStopButton(processStopButton), true);
            switch (currentSearchType)
            {
                case 1:
                    searchWord = globalVars.PrimaryWord;
                    stateCheck = rbtnInclude.Checked;
                    baseSearch(1, matchType, globalVars.PrimaryBookId, globalVars.PrimaryChapNo, globalVars.PrimaryVNo,
                                globalVars.PrimaryWordSeq, searchWord, -1, "", "", -1, "", null, stateCheck);
                    break;
                case 2:
                    searchWord = globalVars.PrimaryWord;
                    secondarySearchWord = globalVars.SecondaryWord;
                    stateCheck = rbtnInclude.Checked;
                    baseSearch(2, matchType, globalVars.PrimaryBookId, globalVars.PrimaryChapNo, globalVars.PrimaryVNo,
                                globalVars.PrimaryWordSeq, searchWord, globalVars.SecondaryBookId, globalVars.SecondaryChapNo,
                                globalVars.SecondaryVNo, globalVars.SecondaryWordSeq, secondarySearchWord,
                                globalVars.UdWordDistance, stateCheck);
                    break;
            }
        }

        /*======================================================================================================*
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                      *
         *                                      LXX Search Methods                                              *
         *                                      ==================                                              *
         *                                                                                                      *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *======================================================================================================*/

        private void baseSearch(int searchType, int matchType, int pBook, String pChap, String pVerse, int pSeq, String pWord,
                                                                int sBook, String sChap, String sVerse, int sSeq, String sWord,
                                 NumericUpDown searchSpan, bool exclude_include)
        {
            /*===============================================================================================================*
             *                                                                                                               *
             *                                                lxxBaseSearch                                                  *
             *                                                =============                                                  *
             *                                                                                                               *
             *  Purpose:                                                                                                     *
             *  =======                                                                                                      *
             *                                                                                                               *
             *  To handle the search for both a basic search and an advanced (two-word) search.                              *
             *                                                                                                               *
             *  Parameters:                                                                                                  *
             *  ==========                                                                                                   *
             *    searchType   If this = 1, the search is basic; 2, the search is more complex                               *
             *    matchType    Possible values                                                                               *
             *                 and significance are:                                                                         *
             *                  Value                       Significance                                                     *
             *                    1     Matches are based on root entry (from source data)                                   *
             *                    2     Matches are "exact" - exact match of the word form except for accents                *
             *       If the primary word has been populated from the main text (by a right click), then:                     *
             *    pBook        The bookId of the primary search source word                                                  *
             *    pChap        The chapter reference of the primary search source word                                       *
             *    pVerse       The verse reference of the primary search source word                                         *
             *    pSeq         The sequence in the verse of the primary search source word                                   *
             *    pWord        The actual primary word (without accents, with vowels)                                        *
             *       If the secondary word has been populated from the main text (by a right click), then:                   *
             *    sBook        The bookId of the secondary search source word                                                *
             *    sChap        The chapter reference of the secondary search source word                                     *
             *    sVerse       The verse reference of the secondary search source word                                       *
             *    sSeq         The sequence in the verse of the secondary search source word                                 *
             *    sWord        The actual secondary word (without accents, with vowels)                                      *
             *    searchSpan   An int value; the number of words before and after the matched word in which the secondary    *
             *                   word must occur for a full match.                                                           *
             *    exclude_include                                                                                            *
             *                 If = true, we *include* all in the listed book category                                       *
             *                 if = false, we include those *not* in the category                                            *
             *                                                                                                               *
             *  Returned variable:                                                                                           *
             *  =================                                                                                            *
             *    A String variable containing all/any search results                                                        *
             *                                                                                                               *
             *===============================================================================================================*/

            bool isWorthProgressing = false;
            String primaryString, secondaryString;
            classMatchResults confirmWords;

            confirmWords = initialMatchProcessing(pBook, pChap, pVerse, pSeq, pWord, sBook, sChap, sVerse, sSeq, sWord);
            if (confirmWords == null) return;
            primaryString = confirmWords.PrimaryWord;
            secondaryString = confirmWords.SecondaryWord;
            isWorthProgressing = isWordGiven;
            if ((currentSearchType == 2) && (!isSWordGiven)) isWorthProgressing = false;
            if (isWorthProgressing)
            {
                // We now have an assured list of words for comparison.  Now hunt for all occurrences
                globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                    globalVars.StatStrip, 1, "Scanning the OT for uses of " + pWord);
                if (searchType == 1) primaryScan(primaryString, matchType);
                else secondaryScan(primaryString, secondaryString, searchSpan);
                isSearchSuccessful = true;
            }
            else isSearchSuccessful = false;
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Single word search complete");
            displayLXXResults();
        }

        private classMatchResults initialMatchProcessing(int pBook, String pChap, String pVerse, int pSeq, String pWord,
                                                          int sBook, String sChap, String sVerse, int sSeq, String sWord)
        {
            String primaryString, secondaryString;
            Tuple<bool, String> returnedCheck = null;
            classMatchResults matchResults;

            listOfPrimaryResults.Clear();
            noOfMatchingVerses = 0;
            isSearchSuccessful = false;
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Analysing the given primary word");
            // 1  Let's find all primary matches first
            // 1a If the primary word is not set, then we need to find an example
            isWordGiven = false;
            primaryString = @"";
            secondaryString = @"";
            if (pBook >= 0)
            {
                // Okay, we have a word.  But does it match?
                returnedCheck = performCheck(pWord, pBook, pChap, pVerse, pSeq);
            }
            else // Otherwise, we have to search for a match so that we can identify the root
            {
                returnedCheck = findARoot( true );
            }
            primaryString = returnedCheck.Item2;
            isWordGiven = returnedCheck.Item1;
            // Now we have something
            if (isWordGiven)
            {
                // Step 2: if it is a secondary search, we need to repeat the process
                //         Note: we must strictly partition the responses for primary and secondary words
                isSWordGiven = false;
                if (currentSearchType == 2)
                {
                    globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                        globalVars.StatStrip, 1, "Analysing the given secondary word");
                    if (sBook >= 0)
                    {
                        // Okay, we have a word.  But does it match?
                        returnedCheck = performCheck(sWord, sBook, sChap, sVerse, sSeq);
                    }
                    else
                    {
                        returnedCheck = findARoot(false);
                    }
                }
                secondaryString = returnedCheck.Item2;
                isSWordGiven = returnedCheck.Item1;
                if (!isSWordGiven) return null;
            }
            else return null;
            matchResults = new classMatchResults();
            matchResults.PrimaryWord = primaryString;
            matchResults.SecondaryWord = secondaryString;
            return matchResults;
        }

        private Tuple<bool, String> performCheck(String foundWord, int bookId, String chapId, String verseId, int seqNo )
        {
            String cleanedString;
            Tuple<String, String, String, String> returnedWordData;
            classSearchVerify verifyResult;

            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, foundWord + " found; checking validity");
            returnedWordData = greekProcs.removeNonGkChars(foundWord);
            cleanedString = returnedWordData.Item4;
            cleanedString = greekProcs.reduceToBareGreek(cleanedString, true);
            verifyResult = verifyWord(bookId, chapId, verseId, seqNo, cleanedString, matchType);
            isWordGiven = verifyResult.IsWordGiven;
            if (isWordGiven) cleanedString = verifyResult.RootWord;
            return new Tuple<bool, String>(isWordGiven, cleanedString);
        }

        private Tuple<bool, String> findARoot(bool isPrimary)
        {
            bool isBreak = false, isWordGiven = false, isRootMatch = true;
            int bdx, cdx, vdx, wdx, noOfBooks, noOfChapters, noOfVerses, noOfWords;
            String givenWord, cleanedWord, retrievedWord, wordType;
            TextBox txtKeyWord;
            classBook currentBook;
            classChapter currentChapter;
            classVerse currentVerse;
            classWord currentWord;

            txtKeyWord = globalVars.getTextbox(0);

            // Get the word _typed_
            if ( isPrimary) txtKeyWord = globalVars.getTextbox(0);
            else txtKeyWord = globalVars.getTextbox(1);
            givenWord = txtKeyWord.Text;
            isRootMatch = (globalVars.getRadioButton(0).Checked);
            // Clean this up by removing any extraneous characters
            cleanedWord = greekProcs.reduceToBareGreek(givenWord, false);
            // Now work through _all_ the books to find an occurrence of this word
            noOfBooks = globalVars.NoOfAllBooks;
            for( bdx = 0; bdx < noOfBooks; bdx++)
            {
                globalVars.BookList.TryGetValue(bdx, out currentBook);
                noOfChapters = currentBook.NoOfChaptersInBook;
                for( cdx = 0; cdx < noOfChapters; cdx++)
                {
                    currentChapter = currentBook.getChapterBySequence(cdx);
                    noOfVerses = currentChapter.NoOfVersesInChapter;
                    for( vdx = 0; vdx < noOfVerses; vdx++)
                    {
                        currentVerse = currentChapter.getVerseBySeqNo(vdx);
                        noOfWords = currentVerse.WordCount;
                        for( wdx = 0; wdx < noOfWords; wdx++)
                        {
                            currentWord = currentVerse.getWordBySeqNo(wdx);
                            retrievedWord = currentWord.AccentlessTextWord;
                            if( String.Compare( retrievedWord, cleanedWord) == 0)
                            {
                                // We've found a match
                                if( isPrimary)
                                {
                                    globalVars.PrimaryBookId = bdx;
                                    globalVars.PrimaryChapNo = currentBook.getChapterRefBySequence( cdx );
                                    globalVars.PrimaryVNo = currentChapter.getVerseRefBySeqNo( vdx );
                                    globalVars.PrimaryWordSeq = wdx;
                                    isBreak = true;
                                    isWordGiven = true;
                                    if(isRootMatch) cleanedWord = currentWord.RootWord;
                                    else cleanedWord = currentWord.AccentlessTextWord;
                                    break;
                                }
                                else
                                {
                                    globalVars.SecondaryBookId = bdx;
                                    globalVars.SecondaryChapNo = currentBook.getChapterRefBySequence(cdx);
                                    globalVars.SecondaryVNo = currentChapter.getVerseRefBySeqNo(vdx);
                                    globalVars.SecondaryWordSeq = wdx;
                                    isBreak = true;
                                    isWordGiven = true;
                                    if (isRootMatch) cleanedWord = currentWord.RootWord;
                                    else cleanedWord = currentWord.AccentlessTextWord;
                                    break;
                                }
                            }
                        }
                        if (isBreak) break;
                    }
                    if( isBreak ) break;
                }
                if( isBreak ) break;
            }
            if (isWordGiven) return new Tuple<bool, string>(true, cleanedWord);
            else
            {
                if (isPrimary) wordType = "Primary";
                else wordType = "Secondary";
                if( isPrimary ) globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage), globalVars.StatStrip, 1, 
                    "A match for the " + wordType + " word, " + txtKeyWord.Text + " wasn't found");
                return new Tuple<bool, string>(false, "");
            }
        }

        private classSearchVerify verifyWord(int bookNo, String chapRef, String verseRef, int wordSeq,
            String wordToVerify, int matchType)
        {
            /*======================================================================================================*
             *                                                                                                      *
             *                                           verifyWord                                                 *
             *                                           ==========                                                 *
             *                                                                                                      *
             *  Purpose:                                                                                            *
             *  =======                                                                                             *
             *                                                                                                      *
             *    (a) to find the root form of the wordToVerify                                                     *
             *    (b) if the word has been entered directly, find the root by matching the word as provided with an *
             *          exact match from the source data.  (Of course, this method is not infallible).              *
             *                                                                                                      *
             *======================================================================================================*/

            int bdx, cdx, vdx, wdx, noOfBooks, noOfChapters, noOfVerses, noOfWords;
            classBook currentBook;
            classChapter currentChapter;
            classVerse currentVerse;
            classWord currentWord;
            classSearchVerify currentVerification;

            if (matchType == 2)
            {
                // We are using exact match comparison.  We have to assume that the words provided are correct,
                //   so there's nothing else to do.
                currentVerification = new classSearchVerify();
                currentVerification.IsWordGiven = true;
                currentVerification.RootWord = wordToVerify;
                return currentVerification;
            }
            else
            {
                if (bookNo >= 0)
                {
                    globalVars.BookList.TryGetValue(bookNo, out currentBook);
                    currentChapter = currentBook.getChapterByChapterRef(chapRef);
                    currentVerse = currentChapter.getVerseByVerseRef(verseRef);
                    currentWord = currentVerse.getWordBySeqNo(wordSeq);
                    currentVerification = new classSearchVerify();
                    currentVerification.IsWordGiven = true;
                    currentVerification.RootWord = currentWord.RootWord;
                    return currentVerification;
                }
                else
                {
                    noOfBooks = globalVars.NoOfAllBooks;
                    for (bdx = 0; bdx < noOfBooks; bdx++)
                    {
                        globalVars.BookList.TryGetValue(bdx, out currentBook);
                        noOfChapters = currentBook.NoOfChaptersInBook;
                        for (cdx = 0; cdx < noOfChapters; cdx++)
                        {
                            currentChapter = currentBook.getChapterBySequence(cdx);
                            noOfVerses = currentChapter.NoOfVersesInChapter;
                            for (vdx = 0; vdx < noOfVerses; vdx++)
                            {
                                currentVerse = currentChapter.getVerseBySeqNo(vdx);
                                noOfWords = currentVerse.WordCount;
                                for (wdx = 0; wdx < noOfWords; wdx++)
                                {
                                    currentWord = currentVerse.getWordBySeqNo(wdx);
                                    if (String.Compare(wordToVerify, currentWord.AccentlessTextWord) == 0)
                                    {
                                        currentVerification = new classSearchVerify();
                                        currentVerification.IsWordGiven = true;
                                        currentVerification.RootWord = currentWord.RootWord;
                                        return currentVerification;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            currentVerification = new classSearchVerify();
            currentVerification.IsWordGiven = false;
            currentVerification.RootWord = "";
            return currentVerification;
        }

        private void primaryScan(String targetWord, int matchType)
        {
            bool isAMatchFound, isExisting = false;
            int noOfBooks, bdx, cdx, vdx, wdx, noOfChaps, noOfVerses, noOfWords;
            String currentRoot, wordCleaned;
            classBook currentBook;
            classChapter currentChapter;
            classVerse currentVerse;
            classWord currentWord;
            classPrimaryResult primaryResult, prevSearchResult;

            noOfBooks = globalVars.NoOfAllBooks;
            for (bdx = 0; bdx < noOfBooks; bdx++)
            {
                // Is the current book in the list to be searched?

                currentBook = null;
                globalVars.BookList.TryGetValue(bdx, out currentBook);
                if (currentBook == null) continue;
                if (!booksToInclude.ContainsValue(currentBook)) continue;
                globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                    globalVars.StatStrip, 1, "Simple scan in process; scanning " + currentBook.BookName);
                noOfChaps = currentBook.NoOfChaptersInBook;
                for (cdx = 0; cdx < noOfChaps; cdx++)
                {
                    currentChapter = currentBook.getChapterBySequence(cdx);
                    noOfVerses = currentChapter.NoOfVersesInChapter;
                    for (vdx = 0; vdx < noOfVerses; vdx++)
                    {
                        currentVerse = currentChapter.getVerseBySeqNo(vdx);
                        noOfWords = currentVerse.WordCount;
                        for (wdx = 0; wdx < noOfWords; wdx++)
                        {
                            isAMatchFound = false;
                            currentWord = currentVerse.getWordBySeqNo(wdx);
                            currentRoot = currentWord.RootWord;
                            wordCleaned = currentWord.AccentlessTextWord;
                            if (matchType == 1) isAMatchFound = (String.Compare(targetWord, currentRoot) == 0);
                            else isAMatchFound = (String.Compare(targetWord, wordCleaned) == 0);
                            if (isAMatchFound)
                            {
                                prevSearchResult = null;
                                isExisting = false;
                                if (noOfMatchingVerses > 0)
                                {
                                    listOfPrimaryResults.TryGetValue(noOfMatchingVerses - 1, out prevSearchResult);
                                    if (prevSearchResult != null)
                                    {
                                        if ((bdx == prevSearchResult.BookId) && (cdx == prevSearchResult.ChapSeq) && (vdx == prevSearchResult.VerseSeq))
                                        {
                                            isExisting = true;
                                        }
                                    }
                                }

                                if (isExisting) primaryResult = prevSearchResult;
                                else
                                {
                                    primaryResult = new classPrimaryResult();
                                    primaryResult.BookId = bdx;
                                    primaryResult.ChapSeq = cdx;
                                    primaryResult.VerseSeq = vdx;
                                    primaryResult.ChapReference = currentBook.getChapterRefBySequence(cdx);
                                    primaryResult.VerseReference = currentChapter.getVerseRefBySeqNo(vdx);
                                    primaryResult.ImpactedVerse = currentVerse;
                                }
                                primaryResult.addWordPosition(wdx);
                                if (primaryResult.NoOfMatchingWords == 1) listOfPrimaryResults.Add(noOfMatchingVerses++, primaryResult);
                            }
                        }
                    }
                }
            }
        }

        private void secondaryScan(String pWord, String sWord, NumericUpDown searchSpan)
        {
            bool isAMatchFound;
            int idx, noOfMatches, jdx, noOfMatchingWords, countAway, arrayIndex, seqCount, pWordSeq, noOfCurrentMatches = 0, tdx;
            String referenceString;
            classVerse[] versePentad;
            SortedList<int, classSearchMatches> currentMatches = new SortedList<int, classSearchMatches>();
            classBook currentBook;
            classVerse currentSVerse, inspectedVerse, nearVerse, dummyVerse;
            classPrimaryResult currentSearchResult;
            classSearchMatches currentSearchMatch;

            primaryScan(pWord, matchType);
            versePentad = new classVerse[5];
            dummyVerse = new classVerse();
            dummyVerse.VerseSeq = -1;
            noOfMatches = noOfMatchingVerses;
            for (idx = 0; idx < noOfMatches; idx++)
            {
                currentSearchResult = null;
                listOfPrimaryResults.TryGetValue(idx, out currentSearchResult);
                // This gives us a match on the primary word, whether it is near a secondary or not.
                // Populate versePentad with two verses before and two verses after the match verse
                globalVars.BookList.TryGetValue(currentSearchResult.BookId, out currentBook);
                referenceString = currentBook.BookName + " " + currentSearchResult.ChapReference + ":" + currentSearchResult.VerseReference;
                globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                    globalVars.StatStrip, 1, "Now looking for secondary matches; scanning " + referenceString);
                //                for (idx = 0; idx < 5; idx++) versePentad[idx] = new classVerse();
                for (tdx = 0; tdx < 5; tdx++) versePentad[tdx] = dummyVerse;
                currentSVerse = currentSearchResult.ImpactedVerse;
                versePentad[2] = currentSVerse;
                nearVerse = currentSVerse.PreviousVerse;
                if (nearVerse != null)
                {
                    versePentad[1] = nearVerse;
                    nearVerse = nearVerse.PreviousVerse;
                    if (nearVerse != null) versePentad[0] = nearVerse;
                }
                nearVerse = currentSVerse.NextVerse;
                if (nearVerse != null)
                {
                    versePentad[3] = nearVerse;
                    nearVerse = nearVerse.NextVerse;
                    if (nearVerse != null) versePentad[4] = nearVerse;
                }
                // Firstly, scan backwards from the match
                noOfMatchingWords = currentSearchResult.NoOfMatchingWords;
                for (jdx = 0; jdx < noOfMatchingWords; jdx++)
                {
                    currentSearchResult.MatchingWordPositions.TryGetValue(jdx, out pWordSeq);
                    inspectedVerse = currentSVerse;
                    seqCount = pWordSeq;
                    arrayIndex = 2;
                    for (countAway = 1; countAway <= (int) searchSpan.Value; countAway++)
                    {
                        seqCount--;
                        if (seqCount < 0)
                        {
                            arrayIndex--;
                            if (arrayIndex < 0) break;
                            inspectedVerse = versePentad[arrayIndex];
                            seqCount = inspectedVerse.WordCount - 1;
                        }
                        isAMatchFound = isThereAMatch(inspectedVerse.getWordBySeqNo(seqCount), matchType, sWord);
                        if (isAMatchFound)
                        {
                            currentSearchMatch = new classSearchMatches();
                            currentSearchMatch.PrimaryScanWord = currentSVerse.getWordBySeqNo(pWordSeq);
                            currentSearchMatch.BookId = currentSearchResult.BookId;
                            currentSearchMatch.PrimaryChapterRef = currentSearchResult.ChapReference;
                            currentSearchMatch.PrimaryVerseRef = currentSearchResult.VerseReference;
                            currentSearchMatch.PrimaryChapterSeq = currentSearchResult.ChapSeq;
                            currentSearchMatch.PrimaryVerseSeq = currentSearchResult.VerseSeq;
                            currentSearchMatch.PrimaryWordSeq = pWordSeq;
                            currentSearchMatch.SecondaryScanWord = inspectedVerse.getWordBySeqNo(seqCount);
                            currentSearchMatch.SecondaryChapterRef = inspectedVerse.ChapRef;
                            currentSearchMatch.SecondaryVerseRef = inspectedVerse.VerseRef;
                            currentSearchMatch.SecondaryChapterSeq = inspectedVerse.ChapSeq;
                            currentSearchMatch.SecondaryVerseSeq = inspectedVerse.VerseSeq;
                            currentSearchMatch.SecondaryWordSeq = seqCount;
                            currentMatches.Add(noOfCurrentMatches++, currentSearchMatch);
                            break;
                        }
                    }
                    // Now count up
                    inspectedVerse = currentSVerse;
                    seqCount = pWordSeq;
                    arrayIndex = 2;
                    for (countAway = 1; countAway <= (int) searchSpan.Value; countAway++)
                    {
                        seqCount++;
                        if (seqCount > inspectedVerse.WordCount - 1)
                        {
                            arrayIndex++;
                            if (arrayIndex > 4) break;
                            inspectedVerse = versePentad[arrayIndex];
                            seqCount = 0;
                        }
                        isAMatchFound = isThereAMatch(inspectedVerse.getWordBySeqNo(seqCount), matchType, sWord);
                        if (isAMatchFound)
                        {
                            currentSearchMatch = new classSearchMatches();
                            currentSearchMatch.PrimaryScanWord = currentSVerse.getWordBySeqNo(pWordSeq);
                            currentSearchMatch.BookId = currentSearchResult.BookId;
                            currentSearchMatch.PrimaryChapterRef = currentSearchResult.ChapReference;
                            currentSearchMatch.PrimaryVerseRef = currentSearchResult.VerseReference;
                            currentSearchMatch.PrimaryChapterSeq = currentSearchResult.ChapSeq;
                            currentSearchMatch.PrimaryVerseSeq = currentSearchResult.VerseSeq;
                            currentSearchMatch.PrimaryWordSeq = pWordSeq;
                            currentSearchMatch.SecondaryScanWord = inspectedVerse.getWordBySeqNo(seqCount);
                            currentSearchMatch.SecondaryChapterRef = inspectedVerse.ChapRef;
                            currentSearchMatch.SecondaryVerseRef = inspectedVerse.VerseRef;
                            currentSearchMatch.SecondaryChapterSeq = inspectedVerse.ChapSeq;
                            currentSearchMatch.SecondaryVerseSeq = inspectedVerse.VerseSeq;
                            currentSearchMatch.SecondaryWordSeq = seqCount;
                            currentMatches.Add(noOfCurrentMatches++, currentSearchMatch);
                            break;
                        }
                    }
                }
            }
            allMatches = currentMatches;
            noOfAllMatches = allMatches.Count;
        }

        private bool isThereAMatch(classWord currentWord, int matchType, String targetWord)
        {
            bool isFound = false;
            String candidateWord;

            switch (matchType)
            {
                case 1:
                    candidateWord = currentWord.RootWord;
                    if (String.Compare(targetWord, candidateWord) == 0) isFound = true;
                    break;
                case 2:
                    candidateWord = currentWord.AccentlessTextWord;
                    if (String.Compare(candidateWord, targetWord) == 0) isFound = true;
                    break;
            }
            return isFound;
        }

        private void displayLXXResults()
        {
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Starting display of results");
            resultsTextView = globalVars.getRichtextItem(4); 
            if (isSearchSuccessful)
            {
                resultsTextView.Invoke( new performRichTextBoxUpdate(updateRichTextBox), resultsTextView, 1, " ");
                displayAlignment = 0;
                if (currentSearchType == 1) displayPrimary();
                else displaySecondary();
            }
        }

        private void displayPrimary()
        {
            /*====================================================================================================*
             *                                                                                                    *
             *                                    collatePrimaryDisplayResults                                    *
             *                                    ============================                                    *
             *                                                                                                    *
             *  This runs as a background thread.  In order to enable this, each search result is stored as an    *
             *    attributed string in a dictionary, which can be accessed by the main thread.  The main thread   *
             *    will inspect this dictionary regularly and display any new results.                             *
             *                                                                                                    *
             *====================================================================================================*/
            // effectively character constants

            int idx, noOfMatches, wdx, noOfWords = 0;

            String workingText, interimText;
            classBook currentBook;
            classVerse currentVerse;
            classWord currentWord;
            classPrimaryResult currentSearchResult;

            noOfMatches = noOfMatchingVerses;
            resultsTextView.Invoke(new performRichTextBoxUpdate(updateRichTextBox), resultsTextView, 0, globalVars.getColourSetting(4, 0));
            for (idx = 0; idx < noOfMatches; idx++)
            {
                if (idx > 0)
                {
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 1), globalVars.getDefinedFontNameByIndex(4, 1),
                        globalVars.getDefinedStyleByIndex(4, 1), globalVars.getColourSetting(4, 1), "\n\n");
                }
                currentSearchResult = null;
                listOfPrimaryResults.TryGetValue(idx, out currentSearchResult);
                currentBook = null;
                globalVars.BookList.TryGetValue(currentSearchResult.BookId, out currentBook);
                currentVerse = currentSearchResult.ImpactedVerse;
                // Where a book name contains spaces, we "bond" the book name by using "\u3000" as a space
                interimText = currentBook.BookName;
                interimText = interimText.Replace(" ", ideographicSpace);
                workingText = interimText + noBreakSpace + currentSearchResult.ChapReference + "." + currentSearchResult.VerseReference;
                globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                    globalVars.StatStrip, 1, "Displaying: " + workingText);
                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 1), globalVars.getDefinedFontNameByIndex(4, 1),
                    globalVars.getDefinedStyleByIndex(4, 1), globalVars.getColourSetting(4, 1), workingText);
                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 1), globalVars.getDefinedFontNameByIndex(4, 1),
                    globalVars.getDefinedStyleByIndex(4, 1), globalVars.getColourSetting(4, 1), ": ");
                noOfWords = currentVerse.WordCount;
                //                listOfWordPositions = [[NSArray alloc] initWithArray: [[currentSearchResult matchingWordPositions] allValues]];
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    currentWord = currentVerse.getWordBySeqNo(wdx);
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                        globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), " " + zeroWidthSpace);
                    if (currentSearchResult.MatchingWordPositions.ContainsValue(wdx))
                    {
                        formattedDisplay(resultsTextView, globalVars.getTextSize(4, 3), globalVars.getDefinedFontNameByIndex(4, 3),
                            globalVars.getDefinedStyleByIndex(4, 3), globalVars.getColourSetting(4, 3), currentWord.TextWord);
                    }
                    else
                    {
                        formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                            globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), currentWord.TextWord);
                    }
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                        globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2),
                        zeroWidthNonJoiner + currentWord.PostWordChars + currentWord.Punctuation);
                }
            }
            globalVars.BtnStop.Invoke(new performProcessStopButton(processStopButton), false);
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Search Results complete");
        }

        private void formattedDisplay( RichTextBox rtxTarget, float textSize, String textName, String textStyle, 
            Color textColour, String text)
        {
            Font newFont;
            FontStyle currentFontStyle = FontStyle.Regular;

            switch (textStyle)
            {
                case "Regular": currentFontStyle = FontStyle.Regular; break;
                case "Bold": currentFontStyle = FontStyle.Bold; break;
                case "Italic": currentFontStyle = FontStyle.Italic; break;
                case "Bold and Italic": currentFontStyle = FontStyle.Bold | FontStyle.Italic; break;
            }
            newFont = new Font(textName, textSize, currentFontStyle);
            resultsTextView.Invoke(new performRichTextBoxUpdate(updateRichTextBox), resultsTextView, 2, newFont);
            resultsTextView.Invoke(new performRichTextBoxUpdate(updateRichTextBox), resultsTextView, 3, textColour);
            resultsTextView.Invoke(new performRichTextBoxUpdate(updateRichTextBox), resultsTextView, 4, text);
        }

        private void displaySecondary()
        {
            /*========================================================================================================================*
             *                                                                                                                        *
             *                                                 displaySecondary                                                       *
             *                                                 ================                                                       *
             *                                                                                                                        *
             *  Manage the display of verses satisfying a complex search, consisting of two words within a set number of words of     *
             *    each other.                                                                                                         *
             *                                                                                                                        *
             *  The starting point of this process is a list of class instances, allMatches, which each list a primary and secondary  *
             *    word that satisfy the search criteria.  Note that:                                                                  *
             *                                                                                                                        *
             *    a) the list will be in strict sequence;                                                                             *
             *    b) the determining word, however, may be either a primary or secondary match;                                       *
             *    c) the matching word (either primary or secondary, that comes second) may be within the same verse or the following *
             *         verse or the one after;                                                                                        *
             *    d) additional matches may occur after the first element of the previous match but before the second;                *
             *    e) specifically, we may get:                                                                                        *
             *           match n: primary is chapter 6.4, word 5 while secondary is 6.5, word 2                                       *
             *           match n+1: primary is chapter 6.4, word 7 while secondary is also 6.5, word 2                                *
             *                                                                                                                        *
             *  Processing:                                                                                                           *
             *  ==========                                                                                                            *
             *                                                                                                                        *
             *  In order to convert the individual matches into information that can be displayed sequentially, we will first convert *
             *    each match to a unique reference value.  To do this, we perform the calculation:                                    *
             *                                                                                                                        *
             *                        referenceValue = 1 000 000 * bookId + 1000 * chapterSeq + verseSeq                              *
             *                                                                                                                        *
             *    This will than be used as a key for a verse reference.  If the source record has the second match in a different    *
             *    verse to the first, then the stored verse information will also be marked as "contiguous" with the next.            *
             *                                                                                                                        *
             *========================================================================================================================*/

            int idx, bdx, primaryChap, primaryVerse, secondaryChap, secondaryVerse, wdx, noOfWords = 0, index = 0, typeCode;
            String referenceText, primaryReferenceValue, secondaryReferenceValue, dictionaryValue, dictionaryKey, interimText, 
                singleResult;
            SortedList< String, classSearchVerse> versesMatched = new SortedList<string, classSearchVerse>();
//            String[] unorderedKeys, orderedKeys;
            classBook currentBook;
            classChapter currentChapter;
            classVerse currentVerse;
            classWord currentWord;
            classSearchVerse primarySearchVerse, secondarySearchVerse;
            classSearchMatches currentMatch;

            resultsTextView = globalVars.getRichtextItem(4);
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Starting display of results");

            // Step 1: Arrange the list of all matches further
            for (idx = 0; idx < noOfAllMatches; idx++)
            {
                currentMatch = null;
                allMatches.TryGetValue(idx, out currentMatch);
                bdx = currentMatch.BookId;
                currentBook = null;
                globalVars.BookList.TryGetValue(bdx, out currentBook);
                primaryChap = currentMatch.PrimaryChapterSeq;
                primaryVerse = currentMatch.PrimaryVerseSeq;
                secondaryChap = currentMatch.SecondaryChapterSeq;
                secondaryVerse = currentMatch.SecondaryVerseSeq;
                primaryReferenceValue = createReferenceValue( bdx, primaryChap,primaryVerse );
                secondaryReferenceValue = createReferenceValue( bdx, secondaryChap, secondaryVerse );
                primarySearchVerse = null;
                versesMatched.TryGetValue( primaryReferenceValue, out primarySearchVerse );
                if (primarySearchVerse == null)
                {
                    primarySearchVerse = new classSearchVerse(globalVars);
                    primarySearchVerse.BookId = bdx;
                    primarySearchVerse.ChapterSeq = primaryChap;
                    primarySearchVerse.VerseSeq = primaryVerse;
                    primarySearchVerse.ChapterReference = currentMatch.PrimaryChapterRef;
                    primarySearchVerse.VerseReference = currentMatch.PrimaryVerseRef;
                    currentChapter = currentBook.getChapterBySequence( primaryChap );
                    primarySearchVerse.ImpactedVerse = currentChapter.getVerseBySeqNo( primaryVerse );
                    versesMatched.Add(primaryReferenceValue, primarySearchVerse );
                }
                primarySearchVerse.addWordPosition(currentMatch.PrimaryWordSeq, 1 );
                secondarySearchVerse = null;
                versesMatched.TryGetValue( secondaryReferenceValue, out secondarySearchVerse);
                if (secondarySearchVerse == null)
                {
                    secondarySearchVerse = new classSearchVerse( globalVars);
                    secondarySearchVerse.BookId = bdx;
                    secondarySearchVerse.ChapterSeq = secondaryChap;
                    secondarySearchVerse.VerseSeq = secondaryVerse;
                    secondarySearchVerse.ChapterReference = currentMatch.SecondaryChapterRef;
                    secondarySearchVerse.VerseReference = currentMatch.SecondaryVerseRef;
                    currentChapter = currentBook.getChapterBySequence( secondaryChap );
                    secondarySearchVerse.ImpactedVerse = currentChapter.getVerseBySeqNo( secondaryVerse );
                    versesMatched.Add(secondaryReferenceValue, secondarySearchVerse);
                }
                secondarySearchVerse.addWordPosition( currentMatch.SecondaryWordSeq, 2 );
                if ( Convert.ToInt32( primaryReferenceValue ) > Convert.ToInt32( secondaryReferenceValue ) )
                    secondarySearchVerse.IsFollowed = true;
        else
                {
                    if (Convert.ToInt32(secondaryReferenceValue) > Convert.ToInt32(primaryReferenceValue))
                        primarySearchVerse.IsFollowed = true;
                }
            }
            // We now have information on all relevant matches
            //            unorderedKeys = versesMatched.Keys;
            //            orderedKeys = [[NSArray alloc] initWithArray: [unorderedKeys sortedArrayUsingSelector:@selector(compare:)]];
            //            idx = -1;
            resultsTextView.Invoke(new performRichTextBoxUpdate(updateRichTextBox), resultsTextView, 1, "");
            foreach ( KeyValuePair<String, classSearchVerse> matchedPair in versesMatched)
            {
                //                ++idx;
                primarySearchVerse = matchedPair.Value;
                currentVerse = primarySearchVerse.ImpactedVerse;
                globalVars.BookList.TryGetValue( primarySearchVerse.BookId, out currentBook );
                interimText = currentBook.BookName;
                interimText.Replace( " ", ideographicSpace );
                referenceText = interimText + noBreakSpace + primarySearchVerse.ChapterReference + "." + primarySearchVerse.VerseReference;
                globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                    globalVars.StatStrip, 1, "Displaying: " + referenceText);
                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 1), globalVars.getDefinedFontNameByIndex(4, 1),
                    globalVars.getDefinedStyleByIndex(4, 1), globalVars.getColourSetting(4, 1), referenceText);
                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 1), globalVars.getDefinedFontNameByIndex(4, 1),
                    globalVars.getDefinedStyleByIndex(4, 1), globalVars.getColourSetting(4, 1), ": ");
                noOfWords = currentVerse.WordCount;
                index = 0;
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    /*---------------------------------------------------------------------------------------------------------*
                    *                                                                                                         *
                    *  A reminder:                                                                                            *
                    *                                                                                                         *
                    *  primarySearchVerse.matchingWordPositions is a dictionary keyed on a sequential integer.  Each entry    *
                    *    gives the word sequence position of a word that matches one of the search criteria, whether primary  *
                    *    or secondary.                                                                                        *
                    *                                                                                                         *
                    *  primarySearchVerse.matchingWordType also has an entry for the same integer sequence but the related    *
                    *    value tells us whether the match is primary (1) or secondary (2).                                    *
                    *                                                                                                         *
                    *  So, as we step through the whole verse, we must check whether wdx matches one of the values for        *
                    *    matchingWordPosition.  If it does, we then need to get the type code, to tell whether it is primary  *
                    *    or secondary, and process it accordingly.                                                            *
                    *                                                                                                         *
                    *  Note that the sequence number (Key) for both dictionaries starts with zero.                            *
                    *                                                                                                         *
                    *---------------------------------------------------------------------------------------------------------*/
                    currentWord = currentVerse.getWordBySeqNo( wdx );
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                        globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), " " + zeroWidthSpace);
                    dictionaryValue = null;
                    {
                        typeCode = 0;
                        foreach ( KeyValuePair<int, int> positionsPair in primarySearchVerse.MatchingWordPositions)
                        {
                            if ( positionsPair.Value == wdx)
                            {
                                primarySearchVerse.MatchingWordType.TryGetValue(positionsPair.Key, out typeCode);
                                break;
                            }
                        }
                        switch (typeCode)
                        {
                            case 0:
                                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                                    globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), currentWord.TextWord);
                                break;
                            case 1:
                                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 3), globalVars.getDefinedFontNameByIndex(4, 3),
                                    globalVars.getDefinedStyleByIndex(4, 3), globalVars.getColourSetting(4, 3), currentWord.TextWord);
                                break;
                            case 2:
                                formattedDisplay(resultsTextView, globalVars.getTextSize(4, 4), globalVars.getDefinedFontNameByIndex(4, 4),
                                    globalVars.getDefinedStyleByIndex(4, 4), globalVars.getColourSetting(4, 4), currentWord.TextWord);
                                break;
                        }
                    }
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                        globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), zeroWidthNonJoiner + currentWord.PostWordChars + currentWord.Punctuation);
                }
                if (! primarySearchVerse.IsFollowed)
                {
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                        globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), "\n\n");
                }
                else
                {
                    formattedDisplay(resultsTextView, globalVars.getTextSize(4, 2), globalVars.getDefinedFontNameByIndex(4, 2),
                        globalVars.getDefinedStyleByIndex(4, 2), globalVars.getColourSetting(4, 2), "\n");
                }
//                lxxSearchResults setObject:singleResult forKey:[globalVarsLXXSearch convertIntegerToString:idx]];
//                lxxLatestResultCount = idx;
            }
            globalVars.BtnStop.Invoke(new performProcessStopButton(processStopButton), false);
            globalVars.StatStrip.Invoke(new performToolStripMessage(displayToolStripMessage),
                globalVars.StatStrip, 1, "Search Results complete");
        }

        private String createReferenceValue(int bookId, int chapId, int verseId)
        {
            return zeroPadding(bookId, 2) + zeroPadding(chapId, 3) + zeroPadding(verseId, 3);
        }

        private String zeroPadding(int sourceNumber, int noOfPlaces)
        {
            int idx;
            String padding, finalNumber;

            padding = "";
            for (idx = 0; idx < noOfPlaces; idx++)
            {
                padding += "0";
            }
            finalNumber = padding + sourceNumber.ToString();
            return finalNumber.Substring(finalNumber.Length - noOfPlaces);
        }

        public void setSearchType()
        {
            if (globalVars.getLabel(0).Visible)
            {
                globalVars.getLabel(0).Visible = false;
                globalVars.UdWordDistance.Visible = false;
                globalVars.getLabel(1).Visible = false;
                globalVars.getTextbox(1).Visible = false;
                globalVars.BtnSearchType.Text = "Advanced Search";
            }
            else
            {
                globalVars.getLabel(0).Visible = true;
                globalVars.UdWordDistance.Visible = true;
                globalVars.getLabel(1).Visible = true;
                globalVars.getTextbox(1).Visible = true;
                globalVars.BtnSearchType.Text = "Basic Search";
            }
        }

        public void stopSearch()
        {
            searchThread.Abort();
            globalVars.BtnStop.Visible = false;
        }

        /*======================================================================================================*
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                      *
         *              Methods relating to search results _after_ results are displayed                        *
         *              ================================================================                        *
         *                                                                                                      *
         *  These methods are to do with either copying results or using a specific result to navigate to the   *
         *    location in the main text area.                                                                   *
         *                                                                                                      *
         *  copyAllResults                      Copy all the results currently in the search results area       *
         *  copySingleResult                    Copy the single result on which the user has clicked            *
         *  updateTextAreaWithSelectedChapter   Find and display the book and chapter on which the user clicked *
         *                                        in the main text area.                                        *
         *  searchResultMouseDown               Used to assist finding details in the above methods             *
         *                                                                                                      *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
        /*======================================================================================================*/

        public void copyAllResults(bool isToClipboard)
        {
            String finalText = "";

            finalText = globalVars.getRichtextItem(4).Text;
            finalText = finalText.Replace(zeroWidthSpace.ToString(), "");
            finalText = finalText.Replace(zeroWidthNonJoiner.ToString(), "");
            finalText = finalText.Replace(noBreakSpace.ToString(), " ");
            finalText = finalText.Replace(ideographicSpace.ToString(), " ");
            if (isToClipboard)
            {
                Clipboard.SetText(finalText);
                MessageBox.Show("Search Results have been copied", "Copy to Clipboard", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                noteProcs.insertTextIntoNote(finalText);
                globalVars.getTabControl(2).SelectedIndex = 0;
            }
        }

        public void copySingleResult(bool isToClipboard)
        {
            String finalText = "";

            finalText = globalVars.LastSelectedSearchVerse;
            if ((finalText == null) || (finalText.Length == 0))
            {
                MessageBox.Show("No result has been selected", "Result Copy Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            finalText = finalText.Replace(zeroWidthSpace.ToString(), "");
            finalText = finalText.Replace(zeroWidthNonJoiner.ToString(), "");
            finalText = finalText.Replace(noBreakSpace.ToString(), " ");
            finalText = finalText.Replace(ideographicSpace.ToString(), " ");
            if (isToClipboard)
            {
                Clipboard.SetText(finalText);
                MessageBox.Show("The search Result has been copied", "Copy to Clipboard", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                noteProcs.insertTextIntoNote(finalText);
                globalVars.getTabControl(2).SelectedIndex = 0; 
            }
        }

        public void updateTextAreaWithSelectedChapter()
        {
            int idx, bookId, versionCode, endPstn;
            String chapAndVerse, chapAlone, verseAlone, refString;
            classBook currentBook;

            refString = globalVars.LastSelectedSearchRef;
            if ((refString == null) || (refString.Length == 0))
            {
                MessageBox.Show("No result has been selected", "Search Result Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            endPstn = refString.LastIndexOf(noBreakSpace);
            // So, a single space seperates the book name from chapter and verse
            chapAndVerse = refString.Substring(endPstn + 1);
            // refString becomes = book name
            refString = refString.Substring(0, endPstn);
            refString = refString.Replace(ideographicSpace.ToString(), " ");
            bookId = -1;
            for( idx = 0; idx < globalVars.NoOfAllBooks; idx++)
            {
                globalVars.BookList.TryGetValue( idx, out currentBook );
                if( String.Compare( currentBook.BookName, refString ) == 0 )
                {
                    bookId = idx;
                    break;
                }
            }
            if( bookId == -1 )
            {
                MessageBox.Show( "Unable to find book reference", "Search Error", MessageBoxButtons.OK, MessageBoxIcon.Error );
                return;
            }
            if (idx < globalVars.NoOfLXXBooks) versionCode = 1;
            else versionCode = 0;
            endPstn = chapAndVerse.IndexOf('.');
            chapAlone = chapAndVerse.Substring(0, endPstn);
            verseAlone = chapAndVerse.Substring(endPstn + 1);
            switch (versionCode)
            {
                case 0:
                    globalVars.getTabControl(0).SelectedIndex = 0;
                    ntText.displayChapter(bookId, chapAlone, false);
                    globalVars.getComboBoxItem(2).SelectedItem = verseAlone;
                    break;
                case 1:
                    globalVars.getTabControl(0).SelectedIndex = 1;
                    lxxText.displayChapter(bookId, chapAlone, false);
                    globalVars.getComboBoxItem(5).SelectedItem = verseAlone;
                    break;
            }
        }

        public void recordMouseEffects(MouseEventArgs e)
        {
            /*========================================================================================================*
             *                                                                                                        *
             *                                         searchResultMouseDown                                          *
             *                                         =====================                                          *
             *                                                                                                        *
             *  This event handler is called from *any* of the RichTextBox controls that are created in the Search    *
             *    area.  It will store the row index of the RichTextBox in which the mouse was clicked.               *
             *                                                                                                        *
             *========================================================================================================*/

            int nStart, nPstn = 0, nEnd;
            String currentVerseText, currentRef, subjectText;
            RichTextBox rtxtCurrent;

            rtxtCurrent = globalVars.getRichtextItem(4);
            if (rtxtCurrent.Text.Length == 0) return;
            nPstn = rtxtCurrent.GetCharIndexFromPosition(new Point(e.X, e.Y));
            // This seems to be true when clicked *beyond* a line - find the start of the current line
            subjectText = rtxtCurrent.Text;
            if (subjectText[nPstn] == '\n') nStart = subjectText.LastIndexOf('\n', nPstn - 1);
            else nStart = subjectText.LastIndexOf('\n', nPstn);
            nStart++;
            // Now the end of the line
            if (subjectText[nPstn] == '\n') nEnd = nPstn;
            else nEnd = subjectText.IndexOf('\n', nPstn);
            if (nEnd == -1) nEnd = subjectText.Length;
            // We can now identify the verse and the line of text associated with it
            currentVerseText = subjectText.Substring(nStart, nEnd - nStart);
            // Now to get the verse number
            nEnd = currentVerseText.IndexOf(':');
            currentRef = currentVerseText.Substring(0, nEnd);
            globalVars.LastSelectedSearchVerse = currentVerseText;
            globalVars.LastSelectedSearchRef = currentRef;
        }
    }
}
